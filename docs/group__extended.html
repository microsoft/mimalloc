<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mi-malloc: Extended Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mimalloc-doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="mimalloc-logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">mi-malloc<span id="projectnumber">&#160;3.2</span>
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__extended.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Extended Functions</div></div>
</div><!--header-->
<div class="contents">

<p>Extended functionality.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga1ea64283508718d9d645c38efc2f4305" id="r_ga1ea64283508718d9d645c38efc2f4305"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1ea64283508718d9d645c38efc2f4305">MI_SMALL_SIZE_MAX</a></td></tr>
<tr class="memdesc:ga1ea64283508718d9d645c38efc2f4305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size allowed for small allocations in <a class="el" href="#ga7f050bc6b897da82692174f5fce59cde" title="Allocate a small object.">mi_malloc_small</a> and <a class="el" href="#ga51c47637e81df0e2f13a2d7a2dec123e" title="Allocate a zero initialized small object.">mi_zalloc_small</a> (usually <code>128*sizeof(void*)</code> (= 1KB on 64-bit systems))  <br /></td></tr>
<tr class="separator:ga1ea64283508718d9d645c38efc2f4305"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga292a45f7dbc7cd23c5352ce1f0002816" id="r_ga292a45f7dbc7cd23c5352ce1f0002816"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga292a45f7dbc7cd23c5352ce1f0002816">mi_deferred_free_fun</a>(bool force, unsigned long long heartbeat, void *arg)</td></tr>
<tr class="memdesc:ga292a45f7dbc7cd23c5352ce1f0002816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of deferred free functions.  <br /></td></tr>
<tr class="separator:ga292a45f7dbc7cd23c5352ce1f0002816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf31cea7d0332a81c8b882cbbdbadb8d" id="r_gadf31cea7d0332a81c8b882cbbdbadb8d"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadf31cea7d0332a81c8b882cbbdbadb8d">mi_output_fun</a>(const char *msg, void *arg)</td></tr>
<tr class="memdesc:gadf31cea7d0332a81c8b882cbbdbadb8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of output functions.  <br /></td></tr>
<tr class="separator:gadf31cea7d0332a81c8b882cbbdbadb8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83fc6a688b322261e1c2deab000b0591" id="r_ga83fc6a688b322261e1c2deab000b0591"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga83fc6a688b322261e1c2deab000b0591">mi_error_fun</a>(int err, void *arg)</td></tr>
<tr class="memdesc:ga83fc6a688b322261e1c2deab000b0591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of error callback functions.  <br /></td></tr>
<tr class="separator:ga83fc6a688b322261e1c2deab000b0591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99fe38650d0b02e0e0f89ee024db91d3" id="r_ga99fe38650d0b02e0e0f89ee024db91d3"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga99fe38650d0b02e0e0f89ee024db91d3">mi_arena_id_t</a></td></tr>
<tr class="memdesc:ga99fe38650d0b02e0e0f89ee024db91d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mimalloc uses large (virtual) memory areas, called "arena"s, from the OS to manage its memory.  <br /></td></tr>
<tr class="separator:ga99fe38650d0b02e0e0f89ee024db91d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c0bcd1fee27c7641e9c3c0d991b3b7d" id="r_ga8c0bcd1fee27c7641e9c3c0d991b3b7d"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8c0bcd1fee27c7641e9c3c0d991b3b7d">mi_subproc_id_t</a></td></tr>
<tr class="memdesc:ga8c0bcd1fee27c7641e9c3c0d991b3b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A process can associate threads with sub-processes.  <br /></td></tr>
<tr class="separator:ga8c0bcd1fee27c7641e9c3c0d991b3b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7f050bc6b897da82692174f5fce59cde" id="r_ga7f050bc6b897da82692174f5fce59cde"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7f050bc6b897da82692174f5fce59cde">mi_malloc_small</a> (size_t size)</td></tr>
<tr class="memdesc:ga7f050bc6b897da82692174f5fce59cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a small object.  <br /></td></tr>
<tr class="separator:ga7f050bc6b897da82692174f5fce59cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51c47637e81df0e2f13a2d7a2dec123e" id="r_ga51c47637e81df0e2f13a2d7a2dec123e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga51c47637e81df0e2f13a2d7a2dec123e">mi_zalloc_small</a> (size_t size)</td></tr>
<tr class="memdesc:ga51c47637e81df0e2f13a2d7a2dec123e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a zero initialized small object.  <br /></td></tr>
<tr class="separator:ga51c47637e81df0e2f13a2d7a2dec123e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga089c859d9eddc5f9b4bd946cd53cebee" id="r_ga089c859d9eddc5f9b4bd946cd53cebee"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga089c859d9eddc5f9b4bd946cd53cebee">mi_usable_size</a> (void *p)</td></tr>
<tr class="memdesc:ga089c859d9eddc5f9b4bd946cd53cebee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the available bytes in a memory block.  <br /></td></tr>
<tr class="separator:ga089c859d9eddc5f9b4bd946cd53cebee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac057927cd06c854b45fe7847e921bd47" id="r_gac057927cd06c854b45fe7847e921bd47"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac057927cd06c854b45fe7847e921bd47">mi_good_size</a> (size_t size)</td></tr>
<tr class="memdesc:gac057927cd06c854b45fe7847e921bd47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the used allocation size.  <br /></td></tr>
<tr class="separator:gac057927cd06c854b45fe7847e921bd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga421430e2226d7d468529cec457396756" id="r_ga421430e2226d7d468529cec457396756"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga421430e2226d7d468529cec457396756">mi_collect</a> (bool force)</td></tr>
<tr class="memdesc:ga421430e2226d7d468529cec457396756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eagerly free memory.  <br /></td></tr>
<tr class="separator:ga421430e2226d7d468529cec457396756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d126e5c62d3badc35445e5d84166df2" id="r_ga2d126e5c62d3badc35445e5d84166df2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2d126e5c62d3badc35445e5d84166df2">mi_stats_print</a> (void *out)</td></tr>
<tr class="memdesc:ga2d126e5c62d3badc35445e5d84166df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated.  <br /></td></tr>
<tr class="separator:ga2d126e5c62d3badc35445e5d84166df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga537f13b299ddf801e49a5a94fde02c79" id="r_ga537f13b299ddf801e49a5a94fde02c79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga537f13b299ddf801e49a5a94fde02c79">mi_stats_print_out</a> (<a class="el" href="#gadf31cea7d0332a81c8b882cbbdbadb8d">mi_output_fun</a> *out, void *arg)</td></tr>
<tr class="memdesc:ga537f13b299ddf801e49a5a94fde02c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the main statistics.  <br /></td></tr>
<tr class="separator:ga537f13b299ddf801e49a5a94fde02c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bb8468b8cfcc6e2a61d98aee85c5f99" id="r_ga3bb8468b8cfcc6e2a61d98aee85c5f99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3bb8468b8cfcc6e2a61d98aee85c5f99">mi_stats_reset</a> (void)</td></tr>
<tr class="memdesc:ga3bb8468b8cfcc6e2a61d98aee85c5f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset statistics.  <br /></td></tr>
<tr class="separator:ga3bb8468b8cfcc6e2a61d98aee85c5f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga854b1de8cb067c7316286c28b2fcd3d1" id="r_ga854b1de8cb067c7316286c28b2fcd3d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga854b1de8cb067c7316286c28b2fcd3d1">mi_stats_merge</a> (void)</td></tr>
<tr class="memdesc:ga854b1de8cb067c7316286c28b2fcd3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge thread local statistics with the main statistics and reset.  <br /></td></tr>
<tr class="separator:ga854b1de8cb067c7316286c28b2fcd3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8e73efc2cbca9ebfdfb166983a04c17" id="r_gaf8e73efc2cbca9ebfdfb166983a04c17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf8e73efc2cbca9ebfdfb166983a04c17">mi_thread_init</a> (void)</td></tr>
<tr class="memdesc:gaf8e73efc2cbca9ebfdfb166983a04c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize mimalloc on a thread.  <br /></td></tr>
<tr class="separator:gaf8e73efc2cbca9ebfdfb166983a04c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ae4581e85453456a0d658b2b98bf7bf" id="r_ga0ae4581e85453456a0d658b2b98bf7bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0ae4581e85453456a0d658b2b98bf7bf">mi_thread_done</a> (void)</td></tr>
<tr class="memdesc:ga0ae4581e85453456a0d658b2b98bf7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninitialize mimalloc on a thread.  <br /></td></tr>
<tr class="separator:ga0ae4581e85453456a0d658b2b98bf7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1dac8476c46cb9eecab767eb40c1525" id="r_gab1dac8476c46cb9eecab767eb40c1525"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab1dac8476c46cb9eecab767eb40c1525">mi_thread_stats_print_out</a> (<a class="el" href="#gadf31cea7d0332a81c8b882cbbdbadb8d">mi_output_fun</a> *out, void *arg)</td></tr>
<tr class="memdesc:gab1dac8476c46cb9eecab767eb40c1525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out heap statistics for this thread.  <br /></td></tr>
<tr class="separator:gab1dac8476c46cb9eecab767eb40c1525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3460a6ca91af97be4058f523d3cb8ece" id="r_ga3460a6ca91af97be4058f523d3cb8ece"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3460a6ca91af97be4058f523d3cb8ece">mi_register_deferred_free</a> (<a class="el" href="#ga292a45f7dbc7cd23c5352ce1f0002816">mi_deferred_free_fun</a> *deferred_free, void *arg)</td></tr>
<tr class="memdesc:ga3460a6ca91af97be4058f523d3cb8ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a deferred free function.  <br /></td></tr>
<tr class="separator:ga3460a6ca91af97be4058f523d3cb8ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5b17ff027cd2150b43a33040250cf3f" id="r_gae5b17ff027cd2150b43a33040250cf3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae5b17ff027cd2150b43a33040250cf3f">mi_register_output</a> (<a class="el" href="#gadf31cea7d0332a81c8b882cbbdbadb8d">mi_output_fun</a> *out, void *arg)</td></tr>
<tr class="memdesc:gae5b17ff027cd2150b43a33040250cf3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an output function.  <br /></td></tr>
<tr class="separator:gae5b17ff027cd2150b43a33040250cf3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1d55e0e894be240827e5d87ec3a1f45" id="r_gaa1d55e0e894be240827e5d87ec3a1f45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa1d55e0e894be240827e5d87ec3a1f45">mi_register_error</a> (<a class="el" href="#ga83fc6a688b322261e1c2deab000b0591">mi_error_fun</a> *errfun, void *arg)</td></tr>
<tr class="memdesc:gaa1d55e0e894be240827e5d87ec3a1f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an error callback function.  <br /></td></tr>
<tr class="separator:gaa1d55e0e894be240827e5d87ec3a1f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f071b10d4df1c3658e04e7fd67a94e6" id="r_ga5f071b10d4df1c3658e04e7fd67a94e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5f071b10d4df1c3658e04e7fd67a94e6">mi_is_in_heap_region</a> (const void *p)</td></tr>
<tr class="memdesc:ga5f071b10d4df1c3658e04e7fd67a94e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a pointer part of our heap?  <br /></td></tr>
<tr class="separator:ga5f071b10d4df1c3658e04e7fd67a94e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00ec3324b6b2591c7fe3677baa30a767" id="r_ga00ec3324b6b2591c7fe3677baa30a767"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga00ec3324b6b2591c7fe3677baa30a767">mi_reserve_os_memory</a> (size_t size, bool commit, bool allow_large)</td></tr>
<tr class="memdesc:ga00ec3324b6b2591c7fe3677baa30a767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve OS memory for use by mimalloc.  <br /></td></tr>
<tr class="separator:ga00ec3324b6b2591c7fe3677baa30a767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee14003b3ae120dc3e30f55c10d2854a" id="r_gaee14003b3ae120dc3e30f55c10d2854a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaee14003b3ae120dc3e30f55c10d2854a">mi_manage_os_memory</a> (void *start, size_t size, bool is_committed, bool is_pinned, bool is_zero, int numa_node)</td></tr>
<tr class="memdesc:gaee14003b3ae120dc3e30f55c10d2854a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage a particular memory area for use by mimalloc.  <br /></td></tr>
<tr class="separator:gaee14003b3ae120dc3e30f55c10d2854a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3132f521fb756fc0e8ec0b74fb58df50" id="r_ga3132f521fb756fc0e8ec0b74fb58df50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3132f521fb756fc0e8ec0b74fb58df50">mi_reserve_huge_os_pages_interleave</a> (size_t pages, size_t numa_nodes, size_t timeout_msecs)</td></tr>
<tr class="memdesc:ga3132f521fb756fc0e8ec0b74fb58df50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve <em>pages</em> of huge OS pages (1GiB) evenly divided over <em>numa_nodes</em> nodes, but stops after at most <code>timeout_msecs</code> seconds.  <br /></td></tr>
<tr class="separator:ga3132f521fb756fc0e8ec0b74fb58df50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7795a13d20087447281858d2c771cca1" id="r_ga7795a13d20087447281858d2c771cca1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7795a13d20087447281858d2c771cca1">mi_reserve_huge_os_pages_at</a> (size_t pages, int numa_node, size_t timeout_msecs)</td></tr>
<tr class="memdesc:ga7795a13d20087447281858d2c771cca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve <em>pages</em> of huge OS pages (1GiB) at a specific <em>numa_node</em>, but stops after at most <code>timeout_msecs</code> seconds.  <br /></td></tr>
<tr class="separator:ga7795a13d20087447281858d2c771cca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad25050b19f30cd79397b227e0157a3f" id="r_gaad25050b19f30cd79397b227e0157a3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaad25050b19f30cd79397b227e0157a3f">mi_is_redirected</a> ()</td></tr>
<tr class="memdesc:gaad25050b19f30cd79397b227e0157a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the C runtime <em>malloc</em> API redirected?  <br /></td></tr>
<tr class="separator:gaad25050b19f30cd79397b227e0157a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d862c2affd5790381da14eb102a364d" id="r_ga7d862c2affd5790381da14eb102a364d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7d862c2affd5790381da14eb102a364d">mi_process_info</a> (size_t *elapsed_msecs, size_t *user_msecs, size_t *system_msecs, size_t *current_rss, size_t *peak_rss, size_t *current_commit, size_t *peak_commit, size_t *page_faults)</td></tr>
<tr class="memdesc:ga7d862c2affd5790381da14eb102a364d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return process information (time and memory usage).  <br /></td></tr>
<tr class="separator:ga7d862c2affd5790381da14eb102a364d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7439207f8f71fb6c382a9ea20b997e7" id="r_gad7439207f8f71fb6c382a9ea20b997e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad7439207f8f71fb6c382a9ea20b997e7">mi_debug_show_arenas</a> (bool show_inuse, bool show_abandoned, bool show_purge)</td></tr>
<tr class="memdesc:gad7439207f8f71fb6c382a9ea20b997e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show all current arena's.  <br /></td></tr>
<tr class="separator:gad7439207f8f71fb6c382a9ea20b997e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a25a00a22151619a0be91a10af7787f" id="r_ga9a25a00a22151619a0be91a10af7787f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9a25a00a22151619a0be91a10af7787f">mi_arena_area</a> (<a class="el" href="#ga99fe38650d0b02e0e0f89ee024db91d3">mi_arena_id_t</a> arena_id, size_t *size)</td></tr>
<tr class="memdesc:ga9a25a00a22151619a0be91a10af7787f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of an arena.  <br /></td></tr>
<tr class="separator:ga9a25a00a22151619a0be91a10af7787f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga591aab1c2bc2ca920e33f0f9f9cb5c52" id="r_ga591aab1c2bc2ca920e33f0f9f9cb5c52"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga591aab1c2bc2ca920e33f0f9f9cb5c52">mi_reserve_huge_os_pages_at_ex</a> (size_t pages, int numa_node, size_t timeout_msecs, bool exclusive, <a class="el" href="#ga99fe38650d0b02e0e0f89ee024db91d3">mi_arena_id_t</a> *arena_id)</td></tr>
<tr class="memdesc:ga591aab1c2bc2ca920e33f0f9f9cb5c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve huge OS pages (1GiB) into a single arena.  <br /></td></tr>
<tr class="separator:ga591aab1c2bc2ca920e33f0f9f9cb5c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32f519797fd9a81acb4f52d36e6d751b" id="r_ga32f519797fd9a81acb4f52d36e6d751b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga32f519797fd9a81acb4f52d36e6d751b">mi_reserve_os_memory_ex</a> (size_t size, bool commit, bool allow_large, bool exclusive, <a class="el" href="#ga99fe38650d0b02e0e0f89ee024db91d3">mi_arena_id_t</a> *arena_id)</td></tr>
<tr class="memdesc:ga32f519797fd9a81acb4f52d36e6d751b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve OS memory to be managed in an arena.  <br /></td></tr>
<tr class="separator:ga32f519797fd9a81acb4f52d36e6d751b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41ce8525d77bbb60f618fa1029994f6e" id="r_ga41ce8525d77bbb60f618fa1029994f6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga41ce8525d77bbb60f618fa1029994f6e">mi_manage_os_memory_ex</a> (void *start, size_t size, bool is_committed, bool is_large, bool is_zero, int numa_node, bool exclusive, <a class="el" href="#ga99fe38650d0b02e0e0f89ee024db91d3">mi_arena_id_t</a> *arena_id)</td></tr>
<tr class="memdesc:ga41ce8525d77bbb60f618fa1029994f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage externally allocated memory as a mimalloc arena.  <br /></td></tr>
<tr class="separator:ga41ce8525d77bbb60f618fa1029994f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf2d9976576d5efd5544be12848af949" id="r_gaaf2d9976576d5efd5544be12848af949"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__heap.html#ga34a47cde5a5b38c29f1aa3c5e76943c2">mi_heap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaf2d9976576d5efd5544be12848af949">mi_heap_new_in_arena</a> (<a class="el" href="#ga99fe38650d0b02e0e0f89ee024db91d3">mi_arena_id_t</a> arena_id)</td></tr>
<tr class="memdesc:gaaf2d9976576d5efd5544be12848af949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new heap that only allocates in the specified arena.  <br /></td></tr>
<tr class="separator:gaaf2d9976576d5efd5544be12848af949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ae360583f4351aa5267ee7e43008faf" id="r_ga3ae360583f4351aa5267ee7e43008faf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__heap.html#ga34a47cde5a5b38c29f1aa3c5e76943c2">mi_heap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3ae360583f4351aa5267ee7e43008faf">mi_heap_new_ex</a> (int heap_tag, bool allow_destroy, <a class="el" href="#ga99fe38650d0b02e0e0f89ee024db91d3">mi_arena_id_t</a> arena_id)</td></tr>
<tr class="memdesc:ga3ae360583f4351aa5267ee7e43008faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new heap.  <br /></td></tr>
<tr class="separator:ga3ae360583f4351aa5267ee7e43008faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ecba0d7ebdc99e71bb985c4a1609806" id="r_ga2ecba0d7ebdc99e71bb985c4a1609806"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga8c0bcd1fee27c7641e9c3c0d991b3b7d">mi_subproc_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2ecba0d7ebdc99e71bb985c4a1609806">mi_subproc_main</a> (void)</td></tr>
<tr class="memdesc:ga2ecba0d7ebdc99e71bb985c4a1609806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the main sub-process identifier.  <br /></td></tr>
<tr class="separator:ga2ecba0d7ebdc99e71bb985c4a1609806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8068cac328e41fa2170faef707315243" id="r_ga8068cac328e41fa2170faef707315243"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga8c0bcd1fee27c7641e9c3c0d991b3b7d">mi_subproc_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8068cac328e41fa2170faef707315243">mi_subproc_new</a> (void)</td></tr>
<tr class="memdesc:ga8068cac328e41fa2170faef707315243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a fresh sub-process (with no associated threads yet).  <br /></td></tr>
<tr class="separator:ga8068cac328e41fa2170faef707315243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7d263e9429bac9ac8345c9d25de610e" id="r_gaa7d263e9429bac9ac8345c9d25de610e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa7d263e9429bac9ac8345c9d25de610e">mi_subproc_delete</a> (<a class="el" href="#ga8c0bcd1fee27c7641e9c3c0d991b3b7d">mi_subproc_id_t</a> subproc)</td></tr>
<tr class="memdesc:gaa7d263e9429bac9ac8345c9d25de610e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a previously created sub-process.  <br /></td></tr>
<tr class="separator:gaa7d263e9429bac9ac8345c9d25de610e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbc53414eb68b275588ec001ce1ddc7c" id="r_gadbc53414eb68b275588ec001ce1ddc7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadbc53414eb68b275588ec001ce1ddc7c">mi_subproc_add_current_thread</a> (<a class="el" href="#ga8c0bcd1fee27c7641e9c3c0d991b3b7d">mi_subproc_id_t</a> subproc)</td></tr>
<tr class="memdesc:gadbc53414eb68b275588ec001ce1ddc7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the current thread to the given sub-process.  <br /></td></tr>
<tr class="separator:gadbc53414eb68b275588ec001ce1ddc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Extended functionality. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga1ea64283508718d9d645c38efc2f4305" name="ga1ea64283508718d9d645c38efc2f4305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ea64283508718d9d645c38efc2f4305">&#9670;&#160;</a></span>MI_SMALL_SIZE_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MI_SMALL_SIZE_MAX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum size allowed for small allocations in <a class="el" href="#ga7f050bc6b897da82692174f5fce59cde" title="Allocate a small object.">mi_malloc_small</a> and <a class="el" href="#ga51c47637e81df0e2f13a2d7a2dec123e" title="Allocate a zero initialized small object.">mi_zalloc_small</a> (usually <code>128*sizeof(void*)</code> (= 1KB on 64-bit systems)) </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga99fe38650d0b02e0e0f89ee024db91d3" name="ga99fe38650d0b02e0e0f89ee024db91d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99fe38650d0b02e0e0f89ee024db91d3">&#9670;&#160;</a></span>mi_arena_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="#ga99fe38650d0b02e0e0f89ee024db91d3">mi_arena_id_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mimalloc uses large (virtual) memory areas, called "arena"s, from the OS to manage its memory. </p>
<p>Each arena has an associated identifier. </p>

</div>
</div>
<a id="ga292a45f7dbc7cd23c5352ce1f0002816" name="ga292a45f7dbc7cd23c5352ce1f0002816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga292a45f7dbc7cd23c5352ce1f0002816">&#9670;&#160;</a></span>mi_deferred_free_fun</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void mi_deferred_free_fun(bool force, unsigned long long heartbeat, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of deferred free functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force</td><td>If <em>true</em> all outstanding items should be freed. </td></tr>
    <tr><td class="paramname">heartbeat</td><td>A monotonically increasing count. </td></tr>
    <tr><td class="paramname">arg</td><td>Argument that was passed at registration to hold extra state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga3460a6ca91af97be4058f523d3cb8ece" title="Register a deferred free function.">mi_register_deferred_free</a> </dd></dl>

</div>
</div>
<a id="ga83fc6a688b322261e1c2deab000b0591" name="ga83fc6a688b322261e1c2deab000b0591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83fc6a688b322261e1c2deab000b0591">&#9670;&#160;</a></span>mi_error_fun</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void mi_error_fun(int err, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of error callback functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>Error code (see <a class="el" href="#gaa1d55e0e894be240827e5d87ec3a1f45" title="Register an error callback function.">mi_register_error()</a> for a complete list). </td></tr>
    <tr><td class="paramname">arg</td><td>Argument that was passed at registration to hold extra state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaa1d55e0e894be240827e5d87ec3a1f45" title="Register an error callback function.">mi_register_error()</a> </dd></dl>

</div>
</div>
<a id="gadf31cea7d0332a81c8b882cbbdbadb8d" name="gadf31cea7d0332a81c8b882cbbdbadb8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf31cea7d0332a81c8b882cbbdbadb8d">&#9670;&#160;</a></span>mi_output_fun</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void mi_output_fun(const char *msg, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of output functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Message to output. </td></tr>
    <tr><td class="paramname">arg</td><td>Argument that was passed at registration to hold extra state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gae5b17ff027cd2150b43a33040250cf3f" title="Register an output function.">mi_register_output()</a> </dd></dl>

</div>
</div>
<a id="ga8c0bcd1fee27c7641e9c3c0d991b3b7d" name="ga8c0bcd1fee27c7641e9c3c0d991b3b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c0bcd1fee27c7641e9c3c0d991b3b7d">&#9670;&#160;</a></span>mi_subproc_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="#ga8c0bcd1fee27c7641e9c3c0d991b3b7d">mi_subproc_id_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A process can associate threads with sub-processes. </p>
<p>A sub-process will not reclaim memory from (abandoned heaps/threads) other subprocesses. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9a25a00a22151619a0be91a10af7787f" name="ga9a25a00a22151619a0be91a10af7787f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a25a00a22151619a0be91a10af7787f">&#9670;&#160;</a></span>mi_arena_area()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * mi_arena_area </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga99fe38650d0b02e0e0f89ee024db91d3">mi_arena_id_t</a></td>          <td class="paramname"><span class="paramname"><em>arena_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size of an arena. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arena_id</td><td>The arena identifier. </td></tr>
    <tr><td class="paramname">size</td><td>Returned size in bytes of the (virtual) arena area. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>base address of the arena. </dd></dl>

</div>
</div>
<a id="ga421430e2226d7d468529cec457396756" name="ga421430e2226d7d468529cec457396756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga421430e2226d7d468529cec457396756">&#9670;&#160;</a></span>mi_collect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_collect </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>force</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eagerly free memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force</td><td>If <em>true</em>, aggressively return memory to the OS (can be expensive!)</td></tr>
  </table>
  </dd>
</dl>
<p>Regular code should not have to call this function. It can be beneficial in very narrow circumstances; in particular, when a long running thread allocates a lot of blocks that are freed by other threads it may improve resource usage by calling this every once in a while. </p>

</div>
</div>
<a id="gad7439207f8f71fb6c382a9ea20b997e7" name="gad7439207f8f71fb6c382a9ea20b997e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7439207f8f71fb6c382a9ea20b997e7">&#9670;&#160;</a></span>mi_debug_show_arenas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_debug_show_arenas </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>show_inuse</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>show_abandoned</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>show_purge</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Show all current arena's. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">show_inuse</td><td>Show the arena blocks that are in use. </td></tr>
    <tr><td class="paramname">show_abandoned</td><td>Show the abandoned arena blocks. </td></tr>
    <tr><td class="paramname">show_purge</td><td>Show arena blocks scheduled for purging. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac057927cd06c854b45fe7847e921bd47" name="gac057927cd06c854b45fe7847e921bd47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac057927cd06c854b45fe7847e921bd47">&#9670;&#160;</a></span>mi_good_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mi_good_size </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the used allocation size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The minimal required size in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size <code>n</code> that will be allocated, where <code>n &gt;= size</code>.</dd></dl>
<p>Generally, <code>mi_usable_size(mi_malloc(size)) == mi_good_size(size)</code>. This can be used to reduce internal wasted space when allocating buffers for example.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga089c859d9eddc5f9b4bd946cd53cebee" title="Return the available bytes in a memory block.">mi_usable_size()</a> </dd></dl>

</div>
</div>
<a id="ga3ae360583f4351aa5267ee7e43008faf" name="ga3ae360583f4351aa5267ee7e43008faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ae360583f4351aa5267ee7e43008faf">&#9670;&#160;</a></span>mi_heap_new_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__heap.html#ga34a47cde5a5b38c29f1aa3c5e76943c2">mi_heap_t</a> * mi_heap_new_ex </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>heap_tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allow_destroy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga99fe38650d0b02e0e0f89ee024db91d3">mi_arena_id_t</a></td>          <td class="paramname"><span class="paramname"><em>arena_id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap_tag</td><td>The heap tag associated with this heap; heaps only reclaim memory between heaps with the same tag. </td></tr>
    <tr><td class="paramname">allow_destroy</td><td>Is <em>mi_heap_destroy</em> allowed? Not allowing this allows the heap to reclaim memory from terminated threads. </td></tr>
    <tr><td class="paramname">arena_id</td><td>If not 0, the heap will only allocate from the specified arena. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new heap or <code>NULL</code> on failure.</dd></dl>
<p>The <em>arena_id</em> can be used by runtimes to allocate only in a specified pre-reserved arena. This is used for example for a compressed pointer heap in Koka. The <em>heap_tag</em> enables heaps to keep objects of a certain type isolated to heaps with that tag. This is used for example in the CPython integration. </p>

</div>
</div>
<a id="gaaf2d9976576d5efd5544be12848af949" name="gaaf2d9976576d5efd5544be12848af949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf2d9976576d5efd5544be12848af949">&#9670;&#160;</a></span>mi_heap_new_in_arena()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__heap.html#ga34a47cde5a5b38c29f1aa3c5e76943c2">mi_heap_t</a> * mi_heap_new_in_arena </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga99fe38650d0b02e0e0f89ee024db91d3">mi_arena_id_t</a></td>          <td class="paramname"><span class="paramname"><em>arena_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new heap that only allocates in the specified arena. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arena_id</td><td>The arena identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new heap or <code>NULL</code>. </dd></dl>

</div>
</div>
<a id="ga5f071b10d4df1c3658e04e7fd67a94e6" name="ga5f071b10d4df1c3658e04e7fd67a94e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f071b10d4df1c3658e04e7fd67a94e6">&#9670;&#160;</a></span>mi_is_in_heap_region()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mi_is_in_heap_region </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is a pointer part of our heap? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if this is a pointer into our heap. This function is relatively fast. </dd></dl>

</div>
</div>
<a id="gaad25050b19f30cd79397b227e0157a3f" name="gaad25050b19f30cd79397b227e0157a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad25050b19f30cd79397b227e0157a3f">&#9670;&#160;</a></span>mi_is_redirected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mi_is_redirected </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the C runtime <em>malloc</em> API redirected? </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if all malloc API calls are redirected to mimalloc.</dd></dl>
<p>Currently only used on Windows. </p>

</div>
</div>
<a id="ga7f050bc6b897da82692174f5fce59cde" name="ga7f050bc6b897da82692174f5fce59cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f050bc6b897da82692174f5fce59cde">&#9670;&#160;</a></span>mi_malloc_small()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * mi_malloc_small </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a small object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size in bytes, can be at most <a class="el" href="#ga1ea64283508718d9d645c38efc2f4305" title="Maximum size allowed for small allocations in mi_malloc_small and mi_zalloc_small (usually 128*sizeof...">MI_SMALL_SIZE_MAX</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to newly allocated memory of at least <em>size</em> bytes, or <em>NULL</em> if out of memory. This function is meant for use in run-time systems for best performance and does not check if <em>size</em> was indeed small &ndash; use with care! </dd></dl>

</div>
</div>
<a id="gaee14003b3ae120dc3e30f55c10d2854a" name="gaee14003b3ae120dc3e30f55c10d2854a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee14003b3ae120dc3e30f55c10d2854a">&#9670;&#160;</a></span>mi_manage_os_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mi_manage_os_memory </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_committed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_pinned</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_zero</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numa_node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manage a particular memory area for use by mimalloc. </p>
<p>This is just like <code>mi_reserve_os_memory</code> except that the area should already be allocated in some manner and available for use my mimalloc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Start of the memory area </td></tr>
    <tr><td class="paramname">size</td><td>The size of the memory area. </td></tr>
    <tr><td class="paramname">is_committed</td><td>Is the area already committed? </td></tr>
    <tr><td class="paramname">is_pinned</td><td>Can the memory not be decommitted or reset? (usually the case for large OS pages) </td></tr>
    <tr><td class="paramname">is_zero</td><td>Does the area consists of zero's? </td></tr>
    <tr><td class="paramname">numa_node</td><td>Possible associated numa node or <code>-1</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if successful, and <em>false</em> on error. </dd></dl>

</div>
</div>
<a id="ga41ce8525d77bbb60f618fa1029994f6e" name="ga41ce8525d77bbb60f618fa1029994f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41ce8525d77bbb60f618fa1029994f6e">&#9670;&#160;</a></span>mi_manage_os_memory_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mi_manage_os_memory_ex </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_committed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_large</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_zero</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numa_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>exclusive</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga99fe38650d0b02e0e0f89ee024db91d3">mi_arena_id_t</a> *</td>          <td class="paramname"><span class="paramname"><em>arena_id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manage externally allocated memory as a mimalloc arena. </p>
<p>This memory will not be freed by mimalloc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Start address of the area. </td></tr>
    <tr><td class="paramname">size</td><td>Size in bytes of the area. </td></tr>
    <tr><td class="paramname">is_committed</td><td>Is the memory already committed? </td></tr>
    <tr><td class="paramname">is_large</td><td>Does it consist of (pinned) large OS pages? </td></tr>
    <tr><td class="paramname">is_zero</td><td>Is the memory zero-initialized? </td></tr>
    <tr><td class="paramname">numa_node</td><td>Associated NUMA node, or -1 to have no NUMA preference. </td></tr>
    <tr><td class="paramname">exclusive</td><td>Is the arena exclusive (where only heaps associated with the arena can allocate in it) </td></tr>
    <tr><td class="paramname">arena_id</td><td>The new arena identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if successful. </dd></dl>

</div>
</div>
<a id="ga7d862c2affd5790381da14eb102a364d" name="ga7d862c2affd5790381da14eb102a364d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d862c2affd5790381da14eb102a364d">&#9670;&#160;</a></span>mi_process_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_process_info </td>
          <td>(</td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>elapsed_msecs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>user_msecs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>system_msecs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>current_rss</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>peak_rss</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>current_commit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>peak_commit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>page_faults</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return process information (time and memory usage). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elapsed_msecs</td><td>Optional. Elapsed wall-clock time of the process in milli-seconds. </td></tr>
    <tr><td class="paramname">user_msecs</td><td>Optional. User time in milli-seconds (as the sum over all threads). </td></tr>
    <tr><td class="paramname">system_msecs</td><td>Optional. System time in milli-seconds. </td></tr>
    <tr><td class="paramname">current_rss</td><td>Optional. Current working set size (touched pages). </td></tr>
    <tr><td class="paramname">peak_rss</td><td>Optional. Peak working set size (touched pages). </td></tr>
    <tr><td class="paramname">current_commit</td><td>Optional. Current committed memory (backed by the page file). </td></tr>
    <tr><td class="paramname">peak_commit</td><td>Optional. Peak committed memory (backed by the page file). </td></tr>
    <tr><td class="paramname">page_faults</td><td>Optional. Count of hard page faults.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>current_rss</em> is precise on Windows and MacOSX; other systems estimate this using <em>current_commit</em>. The <em>commit</em> is precise on Windows but estimated on other systems as the amount of read/write accessible memory reserved by mimalloc. </p>

</div>
</div>
<a id="ga3460a6ca91af97be4058f523d3cb8ece" name="ga3460a6ca91af97be4058f523d3cb8ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3460a6ca91af97be4058f523d3cb8ece">&#9670;&#160;</a></span>mi_register_deferred_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_register_deferred_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga292a45f7dbc7cd23c5352ce1f0002816">mi_deferred_free_fun</a> *</td>          <td class="paramname"><span class="paramname"><em>deferred_free</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a deferred free function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deferred_free</td><td>Address of a deferred free-ing function or <em>NULL</em> to unregister. </td></tr>
    <tr><td class="paramname">arg</td><td>Argument that will be passed on to the deferred free function.</td></tr>
  </table>
  </dd>
</dl>
<p>Some runtime systems use deferred free-ing, for example when using reference counting to limit the worst case free time. Such systems can register (re-entrant) deferred free function to free more memory on demand. When the <em>force</em> parameter is <em>true</em> all possible memory should be freed. The per-thread <em>heartbeat</em> parameter is monotonically increasing and guaranteed to be deterministic if the program allocates deterministically. The <em>deferred_free</em> function is guaranteed to be called deterministically after some number of allocations (regardless of freeing or available free memory). At most one <em>deferred_free</em> function can be active. </p>

</div>
</div>
<a id="gaa1d55e0e894be240827e5d87ec3a1f45" name="gaa1d55e0e894be240827e5d87ec3a1f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1d55e0e894be240827e5d87ec3a1f45">&#9670;&#160;</a></span>mi_register_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_register_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga83fc6a688b322261e1c2deab000b0591">mi_error_fun</a> *</td>          <td class="paramname"><span class="paramname"><em>errfun</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an error callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errfun</td><td>The error function that is called on an error (use <em>NULL</em> for default) </td></tr>
    <tr><td class="paramname">arg</td><td>Extra argument that will be passed on to the error function.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>errfun</em> function is called on an error in mimalloc after emitting an error message (through the output function). It as always legal to just return from the <em>errfun</em> function in which case allocation functions generally return <em>NULL</em> or ignore the condition. The default function only calls abort() when compiled in secure mode with an <em>EFAULT</em> error. The possible error codes are:</p><ul>
<li><em>EAGAIN:</em> Double free was detected (only in debug and secure mode).</li>
<li><em>EFAULT:</em> Corrupted free list or meta-data was detected (only in debug and secure mode).</li>
<li><em>ENOMEM:</em> Not enough memory available to satisfy the request.</li>
<li><em>EOVERFLOW:</em> Too large a request, for example in <a class="el" href="group__malloc.html#ga6686568014b54d1e6c7ac64a076e4f56" title="Allocate zero-initialized count elements of size bytes.">mi_calloc()</a>, the <em>count</em> and <em>size</em> parameters are too large.</li>
<li><em>EINVAL:</em> Trying to free or re-allocate an invalid pointer. </li>
</ul>

</div>
</div>
<a id="gae5b17ff027cd2150b43a33040250cf3f" name="gae5b17ff027cd2150b43a33040250cf3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5b17ff027cd2150b43a33040250cf3f">&#9670;&#160;</a></span>mi_register_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_register_output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gadf31cea7d0332a81c8b882cbbdbadb8d">mi_output_fun</a> *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an output function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output function, use <code>NULL</code> to output to stderr. </td></tr>
    <tr><td class="paramname">arg</td><td>Argument that will be passed on to the output function.</td></tr>
  </table>
  </dd>
</dl>
<p>The <code>out</code> function is called to output any information from mimalloc, like verbose or warning messages. </p>

</div>
</div>
<a id="ga7795a13d20087447281858d2c771cca1" name="ga7795a13d20087447281858d2c771cca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7795a13d20087447281858d2c771cca1">&#9670;&#160;</a></span>mi_reserve_huge_os_pages_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mi_reserve_huge_os_pages_at </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>pages</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numa_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>timeout_msecs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve <em>pages</em> of huge OS pages (1GiB) at a specific <em>numa_node</em>, but stops after at most <code>timeout_msecs</code> seconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pages</td><td>The number of 1GiB pages to reserve. </td></tr>
    <tr><td class="paramname">numa_node</td><td>The NUMA node where the memory is reserved (start at 0). Use -1 for no affinity. </td></tr>
    <tr><td class="paramname">timeout_msecs</td><td>Maximum number of milli-seconds to try reserving, or 0 for no timeout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, <em>ENOMEM</em> if running out of memory, or <em>ETIMEDOUT</em> if timed out.</dd></dl>
<p>The reserved memory is used by mimalloc to satisfy allocations. May quit before <em>timeout_msecs</em> are expired if it estimates it will take more than 1.5 times <em>timeout_msecs</em>. The time limit is needed because on some operating systems it can take a long time to reserve contiguous memory if the physical memory is fragmented. </p>

</div>
</div>
<a id="ga591aab1c2bc2ca920e33f0f9f9cb5c52" name="ga591aab1c2bc2ca920e33f0f9f9cb5c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga591aab1c2bc2ca920e33f0f9f9cb5c52">&#9670;&#160;</a></span>mi_reserve_huge_os_pages_at_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mi_reserve_huge_os_pages_at_ex </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>pages</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numa_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>timeout_msecs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>exclusive</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga99fe38650d0b02e0e0f89ee024db91d3">mi_arena_id_t</a> *</td>          <td class="paramname"><span class="paramname"><em>arena_id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve huge OS pages (1GiB) into a single arena. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pages</td><td>Number of 1GiB pages to reserve. </td></tr>
    <tr><td class="paramname">numa_node</td><td>The associated NUMA node, or -1 for no NUMA preference. </td></tr>
    <tr><td class="paramname">timeout_msecs</td><td>Max amount of milli-seconds this operation is allowed to take. (0 is infinite) </td></tr>
    <tr><td class="paramname">exclusive</td><td>If exclusive, only a heap associated with this arena can allocate in it. </td></tr>
    <tr><td class="paramname">arena_id</td><td>The arena identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, <em>ENOMEM</em> if running out of memory, or <em>ETIMEDOUT</em> if timed out. </dd></dl>

</div>
</div>
<a id="ga3132f521fb756fc0e8ec0b74fb58df50" name="ga3132f521fb756fc0e8ec0b74fb58df50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3132f521fb756fc0e8ec0b74fb58df50">&#9670;&#160;</a></span>mi_reserve_huge_os_pages_interleave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mi_reserve_huge_os_pages_interleave </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>pages</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>numa_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>timeout_msecs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve <em>pages</em> of huge OS pages (1GiB) evenly divided over <em>numa_nodes</em> nodes, but stops after at most <code>timeout_msecs</code> seconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pages</td><td>The number of 1GiB pages to reserve. </td></tr>
    <tr><td class="paramname">numa_nodes</td><td>The number of nodes do evenly divide the pages over, or 0 for using the actual number of NUMA nodes. </td></tr>
    <tr><td class="paramname">timeout_msecs</td><td>Maximum number of milli-seconds to try reserving, or 0 for no timeout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, <em>ENOMEM</em> if running out of memory, or <em>ETIMEDOUT</em> if timed out.</dd></dl>
<p>The reserved memory is used by mimalloc to satisfy allocations. May quit before <em>timeout_msecs</em> are expired if it estimates it will take more than 1.5 times <em>timeout_msecs</em>. The time limit is needed because on some operating systems it can take a long time to reserve contiguous memory if the physical memory is fragmented. </p>

</div>
</div>
<a id="ga00ec3324b6b2591c7fe3677baa30a767" name="ga00ec3324b6b2591c7fe3677baa30a767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00ec3324b6b2591c7fe3677baa30a767">&#9670;&#160;</a></span>mi_reserve_os_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mi_reserve_os_memory </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>commit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allow_large</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve OS memory for use by mimalloc. </p>
<p>Reserved areas are used before allocating from the OS again. By reserving a large area upfront, allocation can be more efficient, and can be better managed on systems without <code>mmap</code>/<code>VirtualAlloc</code> (like WASM for example). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size to reserve. </td></tr>
    <tr><td class="paramname">commit</td><td>Commit the memory upfront. </td></tr>
    <tr><td class="paramname">allow_large</td><td>Allow large OS pages (2MiB) to be used? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>0</em> if successful, and an error code otherwise (e.g. <code>ENOMEM</code>). </dd></dl>

</div>
</div>
<a id="ga32f519797fd9a81acb4f52d36e6d751b" name="ga32f519797fd9a81acb4f52d36e6d751b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32f519797fd9a81acb4f52d36e6d751b">&#9670;&#160;</a></span>mi_reserve_os_memory_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mi_reserve_os_memory_ex </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>commit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allow_large</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>exclusive</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga99fe38650d0b02e0e0f89ee024db91d3">mi_arena_id_t</a> *</td>          <td class="paramname"><span class="paramname"><em>arena_id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve OS memory to be managed in an arena. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size the reserve. </td></tr>
    <tr><td class="paramname">commit</td><td>Should the memory be initially committed? </td></tr>
    <tr><td class="paramname">allow_large</td><td>Allow the use of large OS pages? </td></tr>
    <tr><td class="paramname">exclusive</td><td>Is the returned arena exclusive? </td></tr>
    <tr><td class="paramname">arena_id</td><td>The new arena identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, an error code otherwise. </dd></dl>

</div>
</div>
<a id="ga854b1de8cb067c7316286c28b2fcd3d1" name="ga854b1de8cb067c7316286c28b2fcd3d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga854b1de8cb067c7316286c28b2fcd3d1">&#9670;&#160;</a></span>mi_stats_merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_stats_merge </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge thread local statistics with the main statistics and reset. </p>

</div>
</div>
<a id="ga2d126e5c62d3badc35445e5d84166df2" name="ga2d126e5c62d3badc35445e5d84166df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d126e5c62d3badc35445e5d84166df2">&#9670;&#160;</a></span>mi_stats_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_stats_print </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Ignored, outputs to the registered output function or stderr by default.</td></tr>
  </table>
  </dd>
</dl>
<p>Most detailed when using a debug build. </p>

</div>
</div>
<a id="ga537f13b299ddf801e49a5a94fde02c79" name="ga537f13b299ddf801e49a5a94fde02c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga537f13b299ddf801e49a5a94fde02c79">&#9670;&#160;</a></span>mi_stats_print_out()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_stats_print_out </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gadf31cea7d0332a81c8b882cbbdbadb8d">mi_output_fun</a> *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the main statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>An output function or <em>NULL</em> for the default. </td></tr>
    <tr><td class="paramname">arg</td><td>Optional argument passed to <em>out</em> (if not <em>NULL</em>)</td></tr>
  </table>
  </dd>
</dl>
<p>Most detailed when using a debug build. </p>

</div>
</div>
<a id="ga3bb8468b8cfcc6e2a61d98aee85c5f99" name="ga3bb8468b8cfcc6e2a61d98aee85c5f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bb8468b8cfcc6e2a61d98aee85c5f99">&#9670;&#160;</a></span>mi_stats_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_stats_reset </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset statistics. </p>

</div>
</div>
<a id="gadbc53414eb68b275588ec001ce1ddc7c" name="gadbc53414eb68b275588ec001ce1ddc7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbc53414eb68b275588ec001ce1ddc7c">&#9670;&#160;</a></span>mi_subproc_add_current_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_subproc_add_current_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga8c0bcd1fee27c7641e9c3c0d991b3b7d">mi_subproc_id_t</a></td>          <td class="paramname"><span class="paramname"><em>subproc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the current thread to the given sub-process. </p>
<p>This should be called right after a thread is created (and no allocation has taken place yet) </p>

</div>
</div>
<a id="gaa7d263e9429bac9ac8345c9d25de610e" name="gaa7d263e9429bac9ac8345c9d25de610e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7d263e9429bac9ac8345c9d25de610e">&#9670;&#160;</a></span>mi_subproc_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_subproc_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga8c0bcd1fee27c7641e9c3c0d991b3b7d">mi_subproc_id_t</a></td>          <td class="paramname"><span class="paramname"><em>subproc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a previously created sub-process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subproc</td><td>The sub-process identifier. Only delete sub-processes if all associated threads have terminated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2ecba0d7ebdc99e71bb985c4a1609806" name="ga2ecba0d7ebdc99e71bb985c4a1609806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ecba0d7ebdc99e71bb985c4a1609806">&#9670;&#160;</a></span>mi_subproc_main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga8c0bcd1fee27c7641e9c3c0d991b3b7d">mi_subproc_id_t</a> mi_subproc_main </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the main sub-process identifier. </p>

</div>
</div>
<a id="ga8068cac328e41fa2170faef707315243" name="ga8068cac328e41fa2170faef707315243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8068cac328e41fa2170faef707315243">&#9670;&#160;</a></span>mi_subproc_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga8c0bcd1fee27c7641e9c3c0d991b3b7d">mi_subproc_id_t</a> mi_subproc_new </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a fresh sub-process (with no associated threads yet). </p>
<dl class="section return"><dt>Returns</dt><dd>The new sub-process identifier. </dd></dl>

</div>
</div>
<a id="ga0ae4581e85453456a0d658b2b98bf7bf" name="ga0ae4581e85453456a0d658b2b98bf7bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ae4581e85453456a0d658b2b98bf7bf">&#9670;&#160;</a></span>mi_thread_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_thread_done </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uninitialize mimalloc on a thread. </p>
<p>Should not be used as on most systems (pthreads, windows) this is done automatically. Ensures that any memory that is not freed yet (but will be freed by other threads in the future) is properly handled. </p>

</div>
</div>
<a id="gaf8e73efc2cbca9ebfdfb166983a04c17" name="gaf8e73efc2cbca9ebfdfb166983a04c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8e73efc2cbca9ebfdfb166983a04c17">&#9670;&#160;</a></span>mi_thread_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_thread_init </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize mimalloc on a thread. </p>
<p>Should not be used as on most systems (pthreads, windows) this is done automatically. </p>

</div>
</div>
<a id="gab1dac8476c46cb9eecab767eb40c1525" name="gab1dac8476c46cb9eecab767eb40c1525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1dac8476c46cb9eecab767eb40c1525">&#9670;&#160;</a></span>mi_thread_stats_print_out()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_thread_stats_print_out </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gadf31cea7d0332a81c8b882cbbdbadb8d">mi_output_fun</a> *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out heap statistics for this thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>An output function or <em>NULL</em> for the default. </td></tr>
    <tr><td class="paramname">arg</td><td>Optional argument passed to <em>out</em> (if not <em>NULL</em>)</td></tr>
  </table>
  </dd>
</dl>
<p>Most detailed when using a debug build. </p>

</div>
</div>
<a id="ga089c859d9eddc5f9b4bd946cd53cebee" name="ga089c859d9eddc5f9b4bd946cd53cebee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga089c859d9eddc5f9b4bd946cd53cebee">&#9670;&#160;</a></span>mi_usable_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mi_usable_size </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the available bytes in a memory block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to previously allocated memory (or <em>NULL</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the available bytes in the memory block, or 0 if <em>p</em> was <em>NULL</em>.</dd></dl>
<p>The returned size can be used to call <em>mi_expand</em> successfully. The returned size is always at least equal to the allocated size of <em>p</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/msize?view=vs-2017">_msize</a> (Windows) </dd>
<dd>
<a href="http://man7.org/linux/man-pages/man3/malloc_usable_size.3.html">malloc_usable_size</a> (Linux) </dd>
<dd>
<a class="el" href="#gac057927cd06c854b45fe7847e921bd47" title="Return the used allocation size.">mi_good_size()</a> </dd></dl>

</div>
</div>
<a id="ga51c47637e81df0e2f13a2d7a2dec123e" name="ga51c47637e81df0e2f13a2d7a2dec123e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51c47637e81df0e2f13a2d7a2dec123e">&#9670;&#160;</a></span>mi_zalloc_small()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * mi_zalloc_small </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a zero initialized small object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size in bytes, can be at most <a class="el" href="#ga1ea64283508718d9d645c38efc2f4305" title="Maximum size allowed for small allocations in mi_malloc_small and mi_zalloc_small (usually 128*sizeof...">MI_SMALL_SIZE_MAX</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to newly allocated zero-initialized memory of at least <em>size</em> bytes, or <em>NULL</em> if out of memory. This function is meant for use in run-time systems for best performance and does not check if <em>size</em> was indeed small &ndash; use with care! </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
